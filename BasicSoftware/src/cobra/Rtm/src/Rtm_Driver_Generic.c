/*
 ***********************************************************************************************************************
 *
 * COPYRIGHT RESERVED, ETAS GmbH, 2021. All rights reserved.
 * The reproduction, distribution and utilization of this document as well as the communication of its contents to
 * others without explicit authorization is prohibited. Offenders will be held liable for the payment of damages.
 * All rights reserved in the event of the grant of a patent, utility model or design.
 *
 ***********************************************************************************************************************
 ************************************************************************************************
 * Component : Rtm_Driver_Generic.c
 * Date      : Dec 29, 2022
 * Version   : 2.0
 * Description  : This module implements Rtm functions.
 *                Note: This file contains sample implementation only. It is not part of the
 *                      production deliverables. 
 ***********************************************************************************************
*/

/*! \file
 *
 * \brief Runtime measurement generic implementation of hardware dependent part
 *
 */

/*
 ***********************************************************************************************************************
 * Includes
 ***********************************************************************************************************************
 */

#include "Rtm_Prv.h"
#include "Rtm_Driver_Prv.h"
#include "Rte_Rtm.h" /* Intended crossscheck of the fn prototypes are identical between for BSW and ASW/SWC for
                                some modules acc. to AUTOSAR
                                if this file is not generated by the Rte, please use the template provided */

/*
 ***********************************************************************************************************************
 * Preprocessor defines
 ***********************************************************************************************************************
 */

#if ((RTM_CTRL == STD_ON) && (RTM_TARGET == RTM_TARGET_GENERIC))

/*
 ***********************************************************************************************************************
 * Local typedefs
 ***********************************************************************************************************************
 */

/* Driver states (per core) */
typedef struct
{
    /* Information if measure is running */
    uint32 cntMeasureDepth[RTM_CTRL_CONCURRENT_MEASURE];
} Rtm_DriverStates_Type;



/*
 ***********************************************************************************************************************
 * Variable definition
 ***********************************************************************************************************************
 */

#define RTM_START_SEC_VAR_NO_INIT_UNSPECIFIED
#include "Rtm_MemMap.h"

/* States of the driver */
static VAR (Rtm_DriverStates_Type, RTM_VAR_NO_INIT) Rtm_DriverStates[RTM_NUM_CORES];

#define RTM_STOP_SEC_VAR_NO_INIT_UNSPECIFIED
#include "Rtm_MemMap.h"


/*
 ***********************************************************************************************************************
 * Code
 ***********************************************************************************************************************
 */

#define RTM_START_SEC_CODE_SLOW
#include "Rtm_MemMap.h"

/** Rtm_Driver_PreOSInit ***************************************************************************************/
/*!
 * \brief       Inits the HW for runtime measures, must be called before OS is running
 *
 * \param       void
 * \return      void
 */
FUNC (void, RTM_CODE_SLOW) Rtm_Driver_PreOSInit (void)
{
}

#define RTM_STOP_SEC_CODE_SLOW
#include "Rtm_MemMap.h"

#define RTM_START_SEC_CODE
#include "Rtm_MemMap.h"

/** Rtm_Driver_Init ********************************************************************************************/
/*!
 * \brief       Inits the HW for runtime measures, must be called before setup
 *
 * \param       uint8_least  Internal core ID
 * \return      void
 */
FUNC (void, RTM_CODE) Rtm_Driver_Init (uint8_least coreId)
{
    RTM_PARAM_UNUSED (coreId);
}

/** Rtm_Driver_Shutdown ****************************************************************************************/
/*!
 * \brief       Deactives the HW for runtime measures
 *
 * \param       uint8_least  Internal core ID
 * \return      void
 */
FUNC (void, RTM_CODE) Rtm_Driver_Shutdown (uint8_least coreId)
{
    Rtm_Driver_Disable (coreId);
}

/** Rtm_Driver_Setup *******************************************************************************************/
/*!
 * \brief       Setup HW for configured runtime measures
 *
 * \param       uint8_least                 Internal core ID
 * \return      void
 */
FUNC (void, RTM_CODE) Rtm_Driver_Setup (uint8_least coreId)
{
    /* Id is already set in Rtm_Internal.inputValue[ %concMsrId% ].idMeasured_u32 */ 
    uint8_least i;
    /* Reset depth counter */
    for (i = 0; i < RTM_CTRL_CONCURRENT_MEASURE; i++)
    {
        Rtm_DriverStates[coreId].cntMeasureDepth[i] = 0;
    }
}

/** Rtm_Driver_Disable *****************************************************************************************/
/*!
 * (Temporary) disable HW for runtime measures
 *
 * \param       uint8_least  Core ID
 * \return      void
 */
FUNC (void, RTM_CODE) Rtm_Driver_Disable (uint8_least coreId)
{
    RTM_PARAM_UNUSED (coreId);
}

#define RTM_STOP_SEC_CODE
#include "Rtm_MemMap.h"

#define RTM_START_SEC_CODE_FAST
#include "Rtm_MemMap.h"

/** Rtm_Driver_StartMeasure ******************************************************************************************/
/*!
 * \brief       Handler of a detected measure start.
 *
 * \param       sint8_least   ID of concurrent measure
 * \return      void
 *
 * \note    
 */
FUNC (void, RTM_CODE_FAST) Rtm_Driver_StartMeasure (sint8_least concId)
{
    /* Generate pointer to used structures */
    Rtm_InternalInputValues_Type* pInputValue = &Rtm_Internal.inputValue[concId];
    
    /* In dependency of task id? */
    if ((pInputValue->idTask == 0ul) || (Rtm_CheckCurrentOSObject (pInputValue->idTask)))
    {
        const uint8_least coreId = (uint8_least)Rtm_GetLogicalCoreID();
        
#if (RTM_CROSSCORECOM == STD_ON)
        /* Time between MainFunction and processing of cross core command must be detected */
        /* Global ID equal to core local? */
        if (Rtm_Internal.coresValue[coreId].idMeasured_u32[concId] != pInputValue->idMeasured_u32)
        {
            /* No, this measure must be ignored because it would corrupt the buffer */
            return;
        }
#endif
        /* This block must be atomic, reentrant entry on same core must not occur */
        SchM_Enter_Rtm_CtrlMeasure();
        {
            /* Check state, measure already in progress? */
            if (Rtm_DriverStates[coreId].cntMeasureDepth[concId] == 0)
            {
                /* No, call the measure begin method */
                Rtm_Ctrl_StartMeasure (&Rtm_Internal.coresValue[coreId].dataMeasure[concId]);
                Rtm_DriverStates[coreId].cntMeasureDepth[concId] = 1;
            }
            else
            {
                /* Reentrant */
                /* Measure already active, reentrant or recursive call */
                Rtm_Ctrl_StartMeasureReent (&Rtm_Internal.coresValue[coreId].dataMeasure[concId]);
                Rtm_DriverStates[coreId].cntMeasureDepth[concId]++;
            }
        }
        SchM_Exit_Rtm_CtrlMeasure();
    }
}

/** Rtm_Driver_EndMeasure ******************************************************************************************/
/*!
 * \brief       Handler of a detected measure end.
 *
 * \param       sint8_least   ID of concurrent measure
 * \return      void
 *
 * \note        
 */
FUNC (void, RTM_CODE_FAST) Rtm_Driver_EndMeasure (sint8_least id)
{
    /* Generate pointer to used structures */
    Rtm_InternalInputValues_Type* pInputValue = &Rtm_Internal.inputValue[id];
    
    /* In dependency of task id? */
    if ((pInputValue->idTask == 0ul) || (Rtm_CheckCurrentOSObject (pInputValue->idTask)))
    {
        const uint8_least coreId = (uint8_least)Rtm_GetLogicalCoreID();

#if (RTM_CROSSCORECOM == STD_ON)
        /* Time between MainFunction and processing of cross core command must be detected */
        /* Global ID equal to core local? */
        if (Rtm_Internal.coresValue[coreId].idMeasured_u32[id] != pInputValue->idMeasured_u32)
        {
            /* No, this measure must be ignored because it would corrupt the buffer */
            return;
        }
#endif
        /* This block must be atomic, reentrant entry on same core must not occur */
        SchM_Enter_Rtm_CtrlMeasure();
        {
            /* Check state, outside measure in progress? */
            if (Rtm_DriverStates[coreId].cntMeasureDepth[id] == 1)
            {
                /* Yes, call the measure end method */
                Rtm_Ctrl_EndMeasure (&Rtm_Internal.coresValue[coreId].dataMeasure[id]);
                Rtm_DriverStates[coreId].cntMeasureDepth[id] = 0;
            }
            /* Counter equal 0 occurs if the activating of the measurement is measured, ignore this end */
            else if (Rtm_DriverStates[coreId].cntMeasureDepth[id] != 0)
            {
                /* Reentrant end */
                Rtm_DriverStates[coreId].cntMeasureDepth[id]--;
            }
            /* Concluding else for Misra */
            else
            {
            }
        }
        SchM_Exit_Rtm_CtrlMeasure();
    }
}
 
#define RTM_STOP_SEC_CODE_FAST
#include "Rtm_MemMap.h"


#define RTM_START_SEC_CODE_SLOW
#include "Rtm_MemMap.h"

/** Rtm_Driver_PauseFunction ***********************************************************************************/
/*!
 * \brief       Helper function to set a breakpoint to a function that is never called
 *
 * \param       void
 * \return      void
 *
 * \note        This function must never be called
 */
FUNC (void, RTM_CODE_SLOW) Rtm_Driver_PauseFunction (void)
{
}

#define RTM_STOP_SEC_CODE_SLOW
#include "Rtm_MemMap.h"


#endif

/*
 ***********************************************************************************************************************
 * End of file
 ***********************************************************************************************************************
*/


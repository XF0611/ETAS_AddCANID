/*
 ***********************************************************************************************************************
 *
 * COPYRIGHT RESERVED, ETAS GmbH, 2021. All rights reserved.
 * The reproduction, distribution and utilization of this document as well as the communication of its contents to
 * others without explicit authorization is prohibited. Offenders will be held liable for the payment of damages.
 * All rights reserved in the event of the grant of a patent, utility model or design.
 *
 ***********************************************************************************************************************
 ************************************************************************************************
 * Component : Rtm_MT.c
 * Date      : Dec 29, 2022
 * Version   : 2.0
 * Description  : This module implements Rtm functions.
 *                Note: This file contains sample implementation only. It is not part of the
 *                      production deliverables. 
 ***********************************************************************************************
*/

/*! \file
 *
 * \brief Runtime measurement hardware independent part, measure technique
 *
 */

/*
 ***********************************************************************************************************************
 * Includes
 ***********************************************************************************************************************
 */

#include "Rtm_Prv.h"
#include "Rtm_Driver_Prv.h"
#include "Rte_Rtm.h" /* Intended crossscheck of the fn prototypes are identical between for BSW and ASW/SWC for
                                some modules acc. to AUTOSAR
                                if this file is not generated by the Rte, please use the template provided */

/*
 ***********************************************************************************************************************
 * Local preprocessor defines
 ***********************************************************************************************************************
 */


/*
 ***********************************************************************************************************************
 * Variable definition
 ***********************************************************************************************************************
 */

#define RTM_START_SEC_VAR_CLEARED_32
#include "Rtm_MemMap.h"

/* Calibration value for runtime measure, is acquired in the init function
   and used every time the runtime of an element is measured */
VAR (Rtm_MTCalibrate_Type, RTM_VAR_CLEARED) Rtm_MTCalibrate[RTM_NUM_CORES];

#define RTM_STOP_SEC_VAR_CLEARED_32
#include "Rtm_MemMap.h"


/*
 ***********************************************************************************************************************
 * Code
 ***********************************************************************************************************************
 */

#define RTM_START_SEC_CODE_SLOW
#include "Rtm_MemMap.h"

/** Rtm_MT_Init ******************************************************************************************/
/*!
 * \brief       Initializing function for MT function.
 *
 * \param       void
 * \return      void
 *
 * This is called from Rtm_Init before a measurement takes place.
 */
FUNC (void, RTM_CODE_SLOW) Rtm_MT_Init(void)
{
    Rtm_MTValues_Type mtValue = {0};
    uint32 runTime;
    CoreIdType coreId;

    /* Get core ID */
    coreId = Rtm_GetLogicalCoreID();

    /* No init of local structure for calibration needed */
    
    /* Measure overhead first time */
    Rtm_MT_StartMeasure (&mtValue);
    Rtm_MT_EndMeasure (&mtValue);
    /* Store first overhead */
    runTime = mtValue.actualRT;
    /* Measure overhead second time */
    Rtm_MT_StartMeasure (&mtValue);
    Rtm_MT_EndMeasure (&mtValue);
    /* Build average overhead of both measurements */
    Rtm_MTCalibrate[coreId] = (runTime + mtValue.actualRT) / 2;
}

#define RTM_STOP_SEC_CODE_SLOW
#include "Rtm_MemMap.h"


#define RTM_START_SEC_CODE_FAST
#include "Rtm_MemMap.h"

/** Rtm_MT_StartMeasureWroker ******************************************************************************************/
/*!
 * \brief       Function for start of MT measurement.
 *
 * \param       Rtm_MTValues_Type*   Pointer to structure of MT values of the measured element
 * \param       Rtm_MTValuesPerCore_Type*   Pointer to structure of reentrant MT values of the measured element
 * \return      void
 *
 * A measure start of an universal MT measure. If the second argument is not equal zero reentrant
 * measures are considered, the first argument will be ignored.
 */
FUNC (void, RTM_CODE_FAST) Rtm_MT_StartMeasureWroker (Rtm_MTValues_Type* pMTValue,
                                                                        Rtm_MTValuesPerCore_Type* pReent)
{
    uint32 t_u32;
    
    /* Are reentrant measures possible? */
    if (pReent != 0)
    {
#if ((RTM_CTRL == STD_ON) && (RTM_TARGET == RTM_TARGET_GENERIC))
        /* Should this value be measured with controlled measurement */
        {
            /* Pointer to structure inside array, sub core ID to get the pointer to
               Rtm_MTValuesReentrant */
            sint8_least concId = (sint8_least)RTM_CHECK_ID (pReent - Rtm_GetLogicalCoreID());
            if (concId >= 0)
            {
                /* Start measure (we must take our own timestamps because the MT measure function does not acquire
                   call distance in reentrant case) */
                Rtm_Driver_StartMeasure (concId);
            }
        }
#endif
        /* Reentrant (inside interrupt?) */
        if (pReent->contextID != 0)
        {
            /* Counting reentrant value must be secured with interrupt disable */
            SchM_Enter_Rtm_MTMeasure();
            {
                pReent->cntReentCalls++;
            }
            SchM_Exit_Rtm_MTMeasure();
            return;
        }
        
        /* An interrupt with reentrant measure is possible between query and set of contextID,
           but this does not corrupt the results */
        
        /* Store task/ISR ID */
        pReent->contextID = Rtm_GetCurrentContextID();
        
        /* Set pointer to working structure */
        pMTValue = &(pReent->dataMeasured);
    }
#if ((RTM_CTRL == STD_ON) && (RTM_TARGET == RTM_TARGET_GENERIC))
    else
    {
        /* Should this value be measured with controlled measurement */
        sint8_least concId = (sint8_least)RTM_CHECK_ID (pMTValue);
        if (concId >= 0)
        {
            /* Start measure (we must take our own timestamps because the MT measure function does not acquire
               call distance in reentrant case) */
            Rtm_Driver_StartMeasure (concId);
        }
    }
#endif
    
    /* Get free running counter value */
    t_u32 = Rtm_GetStopwatch();
    
    /* Calculate call distance only if second time called (callBegin is only zero the first time) */
    if (pMTValue->callBegin == 0)
    {
        /* Init minimum runtime on first call */
        pMTValue->minRT = RTM_INIT_MIN_U32;
    }
    else
    {
        /* Calculate call distance */
        pMTValue->callDistance = t_u32 - pMTValue->callBeginStopWatch;
    }
    
    /* Set free timestamp for next call distance */
    pMTValue->callBeginStopWatch = t_u32;

    /* Count calls */
    pMTValue->callCount++;

    /* Set timestamp for net runtime at the end */
    pMTValue->callBegin = Rtm_GetExecutionTime();
}

/** Rtm_MT_EndMeasureWroker ******************************************************************************************/
/*!
 * \brief       Function for stop of MT measurement.
 *
 * \param       Rtm_MTValues_Type*   Pointer to structure of MT values of the measured element
 * \param       Rtm_MTValuesPerCore_Type*   Pointer to structure of reentrant MT values of the measured element
 * \return      void
 *
 * A measure end of an universal MT measure. If the second argument is not equal zero reentrant
 * measures are considered, the first argument will be ignored
 */
FUNC (void, RTM_CODE_FAST) Rtm_MT_EndMeasureWroker (Rtm_MTValues_Type* pMTValue,
                                                                      Rtm_MTValuesPerCore_Type* pReent)
{
    uint32 t_u32;
    CoreIdType coreId;

    /* Get actual net timestamp (for calibration before reentrant query) */
    t_u32 = Rtm_GetExecutionTime ();

    /* Get core ID */
    coreId = Rtm_GetLogicalCoreID();
    
    /* Are reentrant measures possible? */
    if (pReent != 0)
    {
#if ((RTM_CTRL == STD_ON) && (RTM_TARGET == RTM_TARGET_GENERIC))
        /* Should this value be measured with controlled measurement */
        {
            /* Pointer to structure inside array, sub core ID to get the pointer to
               Rtm_MTValuesReentrant */
            sint8_least concId = (sint8_least)RTM_CHECK_ID (pReent - Rtm_GetLogicalCoreID());
            if (concId >= 0)
            {
                /* End measure (we must take our own timestamps because the MT measure function does not acquire
                   call distance in reentrant case) */
                Rtm_Driver_EndMeasure (concId);
            }
        }
#endif
        /* Are we in the same context, if not a reentrant measure of the same object was active */
        if (Rtm_GetCurrentContextID() != pReent->contextID)
        {
            /* Counting reentrant calls already done in start measure */
            return;
        }
        /* Set pointer to working structure */
        pMTValue = &(pReent->dataMeasured);
    }
#if ((RTM_CTRL == STD_ON) && (RTM_TARGET == RTM_TARGET_GENERIC))
    else
    {
        /* Should this value be measured with controlled measurement */
        sint8_least concId = (sint8_least)RTM_CHECK_ID (pMTValue);
        if (concId >= 0)
        {
            /* Start measure (we must take our own timestamps because the MT measure function does not acquire
               call distance in reentrant case) */
            Rtm_Driver_EndMeasure (concId);
        }
    }
#endif
    
    /* Calculate runtime */
    t_u32 = t_u32 - pMTValue->callBegin;
    /* Calibrate with check for underflow (take calibration value from common init core) */
    t_u32 = (t_u32 < Rtm_MTCalibrate[coreId]) ? 0 : t_u32 - Rtm_MTCalibrate[coreId];

    /* Write runtime to RAM */
    pMTValue->actualRT = t_u32;
    if (pMTValue->minRT > t_u32)
    {
        pMTValue->minRT = t_u32;
    }
    if (pMTValue->maxRT < t_u32)
    {
        pMTValue->maxRT = t_u32;
    }

    /* Are reentrant measures possible? */
    if (pReent != 0)
    {
        /* New measure possible after writing 0 here */
        pReent->contextID = 0;
    }
}

#define RTM_STOP_SEC_CODE_FAST
#include "Rtm_MemMap.h"

/*
 ***********************************************************************************************************************
 * End of file
 ***********************************************************************************************************************
*/


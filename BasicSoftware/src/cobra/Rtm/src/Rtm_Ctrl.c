/*
 ***********************************************************************************************************************
 *
 * COPYRIGHT RESERVED, ETAS GmbH, 2021. All rights reserved.
 * The reproduction, distribution and utilization of this document as well as the communication of its contents to
 * others without explicit authorization is prohibited. Offenders will be held liable for the payment of damages.
 * All rights reserved in the event of the grant of a patent, utility model or design.
 *
 ***********************************************************************************************************************
 ************************************************************************************************
 * Component : Rtm_Ctrl.c
 * Date      : Dec 29, 2022
 * Version   : 2.0
 * Description  : This module implements Rtm functions.
 *                Note: This file contains sample implementation only. It is not part of the
 *                      production deliverables. 
 ***********************************************************************************************
*/

/*! \file
 *
 * \brief Runtime measurement control interface
 *
 * This file contains the functionality to control Rtm from outside.
 *
 */

/*
 ***********************************************************************************************************************
 * Includes
 ***********************************************************************************************************************
 */

#include "Rtm_Prv.h"
#include "Rtm_Driver_Prv.h"

/* Include RTE header to access input structure */
#include "SchM_Rtm.h" /* if this file is not generated by the Rte, please use the template provided */
#include "Rte_Rtm.h" /* Intended crossscheck of the fn prototypes are identical between for BSW and ASW/SWC for
                                some modules acc. to AUTOSAR
                                if this file is not generated by the Rte, please use the template provided */

/* Run-time controlled measurement active? */
#if (RTM_CTRL == STD_ON)

/*
 ***********************************************************************************************************************
 * Prototypes of local functions only used here (maybe auto inlined)
 ***********************************************************************************************************************
 */

#define RTM_START_SEC_CODE
#include "Rtm_MemMap.h"

static FUNC (void, RTM_CODE) Rtm_Ctrl_Calib (uint8_least coreId);
static FUNC (void, RTM_CODE) Rtm_Ctrl_TurnOn (uint8_least coreId);
static FUNC (void, RTM_CODE) Rtm_Ctrl_TurnOff (uint8_least coreId);
static FUNC (void, RTM_CODE) Rtm_Ctrl_Trigger (uint8_least coreId);
static FUNC (void, RTM_CODE) Rtm_Ctrl_GenSample (uint8_least coreId);
static FUNC (void, RTM_CODE) Rtm_Ctrl_Configure (void);
#if (RTM_CROSSCORECOM == STD_ON)
static FUNC (void, RTM_CODE) Rtm_Ctrl_IssueCrossCoreCommand (uint8_least cmd,uint8_least coreId);
#endif

#define RTM_STOP_SEC_CODE
#include "Rtm_MemMap.h"


/*
 ***********************************************************************************************************************
 * Variable definition
 ***********************************************************************************************************************
 */


#define RTM_START_SEC_VAR_CLEARED_UNSPECIFIED
#include "Rtm_MemMap.h"

/* Define input structure here if it is not generated by RTE */
#if (RTM_INTERFACE != RTM_INTERFACE_CALIBMEAS)
/* Readonly input structure */
VAR (volatile Rtm_Input_Type, RTM_VAR_CLEARED) Rtm_Input;
#endif

/* Output structure */
VAR (Rtm_Output_Type, RTM_VAR_CLEARED) Rtm_Output;

/* Only if there are more than 1 core */
#if (RTM_CROSSCORECOM == STD_ON)
/* Cross core command */
VAR (uint32, RTM_VAR_CLEARED) Rtm_Ctrl_CrossCoreCommand_u32;
#endif

/* Internal structure */
VAR (Rtm_Internal_Type,RTM_VAR_CLEARED) Rtm_Internal;

/* Debug variables */
#ifdef RTM_DEBUG
VAR (uint32, RTM_VAR_CLEARED) Rtm_DebugRuntimeOverhead_u32;
#endif

#define RTM_STOP_SEC_VAR_CLEARED_UNSPECIFIED
#include "Rtm_MemMap.h"

#define RTM_START_SEC_CONST_UNSPECIFIED
#include "Rtm_MemMap.h"

/* Generate constant to deliver informations to the frontend (12 byte) */
CONST (volatile Rtm_CtrlConfig_Type, RTM_CONST) Rtm_CtrlConfig =
{
    0xabcdef,                     /* uint32 endiannessDetection; */
    RTM_TICKS_PER_SECOND,         /* uint32 ticksPerSecond; */
    RTM_MAINFCT_CALLS_PER_MINUTE, /* uint8 samplesPerSecond; */
    RTM_CTRL_PROTOVERSION,        /* uint8 protocolVersion;  */
    RTM_CTRL_CONCURRENT_MEASURE,  /* uint8 concurrentMeasures; */
    RTM_NUM_CORES                 /* uint8 numberOfCores; */
};

#define RTM_STOP_SEC_CONST_UNSPECIFIED
#include "Rtm_MemMap.h"



/*
 ***********************************************************************************************************************
 * Code
 ***********************************************************************************************************************
 */

#define RTM_START_SEC_CODE_SLOW
#include "Rtm_MemMap.h"

/** Rtm_Ctrl_Init **********************************************************************************************/
/*!
 * \brief       Initializing function for submodule control
 *
 * \param       void
 * \return      void
 *
 */
FUNC (void, RTM_CODE_SLOW) Rtm_Ctrl_Init (void)
{
    CoreIdType coreId;

    /* Get core ID */
    coreId = Rtm_GetLogicalCoreID();

    /* Force <Rtm_CtrlConfig> to be linked */
    /* MISRA RULE 11.3 VIOLATION: Cast from pointer type to integral type is necessary in this case */
    Rtm_Internal.coresValue[coreId].timeSampleBegin = (uint32) &Rtm_CtrlConfig;
}

#define RTM_STOP_SEC_CODE_SLOW
#include "Rtm_MemMap.h"

#define RTM_START_SEC_CODE
#include "Rtm_MemMap.h"

/** Rtm_Ctrl_MainFunction **************************************************************************************/
/*!
 * \brief       Main function for master core
 *
 * \param       void
 * \return      void
 *
 * It is periodical called from <Rtm_MainFunction>.
 * It interprets the input structure and controls the runtime measure and sends commands to the other cores.
 */
FUNC (void, RTM_CODE) Rtm_Ctrl_MainFunction(void)
{
    static uint8 sampleDiv_u8 = 0;
    static uint8 sampleTime_u8 = 0;
#if (RTM_CROSSCORECOM == STD_ON)
    static uint8 crossCoreCommandIssued_u8 = RTM_CCC_NOTHING;
#endif

    /* Local input structure pointer */
    volatile Rtm_Input_Type* pCtrlInput;

    /* Core id */
    const uint8_least coreId = (uint8_least)Rtm_GetLogicalCoreID();

    /* Get input */
    pCtrlInput = SchM_CData_Rtm_Rtm_Input_st();

#if (RTM_CROSSCORECOM == STD_ON)
    /* In last cycle cross core command issued? */
    if (crossCoreCommandIssued_u8 != RTM_CCC_NOTHING)
    {
        /* Check if old commands to cores were successfully processed */
        if (Rtm_Ctrl_CrossCoreCommand_u32 == 0)
        {
            if (crossCoreCommandIssued_u8 == RTM_CCC_TURNOFF)
            {
                /* Reset sample counter now */
                Rtm_Output.cntOutputSample = 0;
                crossCoreCommandIssued_u8 = RTM_CCC_NOTHING;
            }
            else if (crossCoreCommandIssued_u8 == RTM_CCC_TRIGGER)
            {
                /* Generate sample */
                Rtm_Ctrl_GenSample (coreId);
                /* Increment sample counter */
                Rtm_Output.cntOutputSample++;
                crossCoreCommandIssued_u8 = RTM_CCC_NOTHING;
            }
            else if (crossCoreCommandIssued_u8 == RTM_CCC_TURNON)
            {
                /* Increment sample counter */
                Rtm_Output.cntOutputSample = 1;
                crossCoreCommandIssued_u8 = RTM_CCC_NOTHING;
            }
            else if (crossCoreCommandIssued_u8 == RTM_CCC_CALIB)
            {
                /* Calibration is ready on all cores */
                /* Configure the first measurement */
                Rtm_Ctrl_Configure ();
                /* This block must be atomic, measurements must not take place inside a preemption (e.g. interrupt)*/
                SchM_Enter_Rtm_CtrlTrigger();
                {
                    /* Turn on the measurement on master core (on which we are currently running) */
                    Rtm_Ctrl_TurnOn (coreId);
                }
                SchM_Exit_Rtm_CtrlTrigger();

                /* Copy configured sample time */
                sampleTime_u8 = sampleDiv_u8 = pCtrlInput->tiSampleTime_u8;

                /* Signal other cores that measurement should be turned on */
                Rtm_Ctrl_IssueCrossCoreCommand (RTM_CCC_TURNON, coreId);
                crossCoreCommandIssued_u8 = RTM_CCC_TURNON;
                
                /* Return here because sampleDiv_u8 must not be decremented in this cycle */
                return;
            }
            else
            {
                /* Do nothing. */
            }
        }
        else
        {
# ifdef RTM_DEBUG
            Rtm_Assert();
# endif
            /* Return here, call of the main function will be completely ignored because other cores are not ready */
            return;
        }
    }
#endif /* #if (RTM_CROSSCORECOM == STD_ON) */
    /* Measurement active ? */
    if (sampleDiv_u8 != 0)
    {
        /* Should the measurement be turn off? */
        if (pCtrlInput->tiSampleTime_u8 == 0)
        {
            /******* Turn off *******/
            /* Reset counter and mirror of sample time */
            sampleTime_u8 = sampleDiv_u8 = 0;
            /* Halt the measurement on current core */
            Rtm_Ctrl_TurnOff (coreId);
#if (RTM_CROSSCORECOM == STD_ON)
            /* Signal other cores that measurement should be turned off */
            Rtm_Ctrl_IssueCrossCoreCommand (RTM_CCC_TURNOFF, coreId);
            crossCoreCommandIssued_u8 = RTM_CCC_TURNOFF;
#else
            /* Reset sample counter if only one core is configured */
            Rtm_Output.cntOutputSample = 0;
#endif
        }
        else
        {
            /* Count time */
            --sampleDiv_u8;
            /* Sample at the end ? */
            if (sampleDiv_u8 == 0)
            {
                /******* Sample *******/
                /* Check if frontend is ready to receive new data */
                if (pCtrlInput->ctTrigger_u8 == Rtm_Output.cntOutputSample)
                {
                    /******* Trigger *******/
                    /* Reset sample divisor */
                    sampleDiv_u8 = sampleTime_u8;
                    /* Configure the measurement for next sample */
                    Rtm_Ctrl_Configure ();
                    /* This block must be atomic, measurements must not take place inside a preemtion (e.g. interrupt)*/
                    SchM_Enter_Rtm_CtrlTrigger();
                    {
                        /* Generate trigger for this core */
                        Rtm_Ctrl_Trigger (coreId);
                    }
                    SchM_Exit_Rtm_CtrlTrigger();
#if (RTM_CROSSCORECOM == STD_ON)
                    /* Signal other cores that a sample should be generated */
                    Rtm_Ctrl_IssueCrossCoreCommand (RTM_CCC_TRIGGER, coreId);
                    crossCoreCommandIssued_u8 = RTM_CCC_TRIGGER;
#else
                    /* Generate sample */
                    Rtm_Ctrl_GenSample (coreId);
                    /* Increment sample counter if only one core is configured */
                    Rtm_Output.cntOutputSample++;
#endif
                }
                else
                {
                    /* Frontend is not ready to receive new data */
                    /* Reset sample divisor to check frontend synchronisation in next cycle */
                    sampleDiv_u8 = 1;
                }
            }
        }
    }
    /* Measurement is turned off, should it be turned on ? */
    else if (pCtrlInput->tiSampleTime_u8 != 0)
    {
        /******* Turn on *******/
        uint8_least c, i;

        /* Reset all internal buffer values */
        for (c = 0; c < RTM_NUM_CORES; c++)
        {
            for (i = 0; i < RTM_CTRL_CONCURRENT_MEASURE; i++)
            {
                Rtm_Internal.coresValue[c].dataMeasure[i].accuRT = 0;
                Rtm_Internal.coresValue[c].dataMeasure[i].minRT = RTM_INIT_MIN_U32;
                Rtm_Internal.coresValue[c].dataMeasure[i].maxRT = 0;
                Rtm_Internal.coresValue[c].dataMeasure[i].accuCallDistance = 0;
                Rtm_Internal.coresValue[c].dataMeasure[i].minCallDistance = RTM_INIT_MIN_U32;
                Rtm_Internal.coresValue[c].dataMeasure[i].maxCallDistance = 0;
                Rtm_Internal.coresValue[c].dataMeasure[i].cntCallsRT = 0;
                Rtm_Internal.coresValue[c].dataMeasure[i].cntReentCalls = 0;
                /* Reset runtime timestamp to detect sample generation while a measured element is active */
                Rtm_Internal.coresValue[c].dataMeasure[i].callBegin = 0;
#if (RTM_CROSSCORECOM == STD_ON)
                /* Reset global input ID to core local to disable the SW measure */
                Rtm_Internal.coresValue[c].idMeasured_u32[i] = NOT_CALLED;
#endif
            }
        }
        /* Calibration always in first cycle */
        /* Setup measure to an empty function */
        /* MISRA RULE 11.3 VIOLATION: Cast from function pointer type to integral type is necessary in this case */
        Rtm_Internal.inputValue[0].idMeasured_u32 = (uint32)&Rtm_EmptyFunc;
        Rtm_Internal.inputValue[0].idTask = 0;
        /* Other conc. measure configs must be cleared (to ensure buffer values are unchanged) */
        for (i = 1; i < RTM_CTRL_CONCURRENT_MEASURE; i++)
        {
            Rtm_Internal.inputValue[i].idMeasured_u32 = 0;
            Rtm_Internal.inputValue[i].idTask = 0;
        }
        /* This block must be atomic, measurements must not take place inside a preemption (e.g. interrupt)*/
        SchM_Enter_Rtm_CtrlTrigger();
        {
            /* Calibrate the measurement on master core (on which we are currently running) */
            Rtm_Ctrl_Calib (coreId);
        }
        SchM_Exit_Rtm_CtrlTrigger();

#if (RTM_CROSSCORECOM == STD_ON)
        /* On multi core we must wait one cycle so all cores are calibrated  */
        /* Signal other cores that measurement should be calibrated */
        Rtm_Ctrl_IssueCrossCoreCommand (RTM_CCC_CALIB, coreId);
        crossCoreCommandIssued_u8 = RTM_CCC_CALIB;
#else
        /* On single core we can immediately start to measure */
        /* Configure the measurement */
        Rtm_Ctrl_Configure ();
        /* This block must be atomic, measurements must not take place inside a preemtion (e.g. interrupt)*/
        SchM_Enter_Rtm_CtrlTrigger();
        {
            /* Turn on the measurement on master core (on which we are currently running) */
            Rtm_Ctrl_TurnOn (coreId);
        }
        SchM_Exit_Rtm_CtrlTrigger();
        /* Copy configured sample time */
        sampleTime_u8 = sampleDiv_u8 = pCtrlInput->tiSampleTime_u8;
        /* Set sample counter */
        Rtm_Output.cntOutputSample = 1;
#endif
    }
    else
    {
        /* Do nothing. */
    }
}


#if (RTM_CROSSCORECOM == STD_ON)
/** Rtm_Ctrl_IssueCrossCoreCommand *****************************************************************************/
/*!
 * \brief       Issue a cross core command
 *
 * \param       uint8_least   Command to execute (RTM_CCC_xxxx)
 * \return      void
 *
 * It is called from <Rtm_Ctrl_MainFunction> to signal commands to other cores.
 */
static FUNC (void, RTM_CODE) Rtm_Ctrl_IssueCrossCoreCommand (uint8_least cmd, uint8_least coreId)
{
    /* Generate uint8 pointer to uint32 cross core command variable because we cannot use masks to access
     * it because of possible concurrent accesses from other cores */
    /* MISRA RULE 11.4 VIOLATION: Cast of pointer is necessary in this case */
    uint8* const crossCoreCommand = (uint8*)&Rtm_Ctrl_CrossCoreCommand_u32;
    uint8_least i;

    for (i = 0; i < RTM_NUM_CORES; i++)
    {
        if (coreId != i)
        {
            crossCoreCommand[i] = (uint8)cmd;
        }
    }
}

/** Rtm_Ctrl_CrossCoreMainFunction *****************************************************************************/
/*!
 * \brief       Main function for all slave cores (on multicore called inside task end hook)
 *
 * \param       uint8_least   Core ID of the currently running core
 * \param       uint8_least   Command to execute (RTM_CCC_xxxx)
 * \return      void
 *
 * Main function for Rtm for other cores
 * It is called from <Rtm_TaskEnd> when a command is pending.
 */
FUNC (void, RTM_CODE) Rtm_Ctrl_CrossCoreMainFunction (uint8_least coreId, uint8_least cmd)
{
    /* Interpret command */
    if (cmd == RTM_CCC_TRIGGER)
    {
        /* Trigger: Next cycle is triggered, copy buffer  */
        Rtm_Ctrl_Trigger (coreId);
    }
    else if (cmd == (RTM_CCC_TURNOFF))
    {
        /* Turn off: End a measure cycle, do not copy something */
        Rtm_Ctrl_TurnOff (coreId);
    }
    else if (cmd == RTM_CCC_TURNON)
    {
        /* Turn on: Initial command to turn a measure cycle on */
        Rtm_Ctrl_TurnOn (coreId);
    }
    else if (cmd == RTM_CCC_CALIB)
    {
        /* Calib: Calibrate the measure on this core */
        Rtm_Ctrl_Calib (coreId);
    }
    /* For misra */
    else  {   }
}

#endif /* (RTM_CROSSCORECOM == STD_ON) */


/** Rtm_Ctrl_Calib *********************************************************************************************/
/*!
 * \brief       Calibrates the runtime measurement (on multicore called also inside task end hook)
 *
 * \param       uint8_least  ID of the currently running core
 * \return      void
 *
 * \note        This must be called with disables interrupts
 *
 * Calibrates the runtime measurement (separate calibration for each core).
 * Called from <Rtm_Ctrl_MainFunction> or <Rtm_Ctrl_CrossCoreMainFunction> when a measure is started.
 * Measures a empty function 2 times and build avrg runtime of it.
 */
static FUNC (void, RTM_CODE) Rtm_Ctrl_Calib (uint8_least coreId)
{
    /* Pointer to structures */
    Rtm_InternalCore_Type* pInternalCore = &Rtm_Internal.coresValue[coreId];

    /* Init driver hardware */
    Rtm_Driver_Init (coreId);

#if (RTM_NUM_CORES != 1)
    /* Copy global input ID to core local to enable the SW measure */
    pInternalCore->idMeasured_u32[0] = Rtm_Internal.inputValue[0].idMeasured_u32;
#endif

    /* Setup breakpoint units to empty function to calibrate */
    Rtm_Driver_Setup (coreId);

#if (RTM_TARGET == RTM_TARGET_GENERIC)
    /* Measure empty function, instrumented */
    RTM_MSR_PROC (Rtm_EmptyFunc);
    RTM_MSR_PROC (Rtm_EmptyFunc);
#else
    /* Further extension options. */
#endif
    /* Calibration value for net runtime */
    pInternalCore->timeCalibrate = pInternalCore->dataMeasure[0].accuRT / 2;
#ifdef RTM_DEBUG
    /* Check calibration, because of cache the difference of the two samples can be huge */
    if (pInternalCore->timeCalibrate == 0 ||
            pInternalCore->dataMeasure[0].maxRT -
            pInternalCore->dataMeasure[0].minRT > 300)
    {
        Rtm_Assert();
    }
    /* In <pInternalCore->dataMeasure[0].maxCallDistance>
     * we have the exact overhead (for the core in ticks) of one measure (with call to trap handler aso) */
    Rtm_DebugRuntimeOverhead_u32 = pInternalCore->dataMeasure[0].accuCallDistance;
#endif

    /* Reset used values */
    pInternalCore->dataMeasure[0].accuRT = 0;
    pInternalCore->dataMeasure[0].minRT = RTM_INIT_MIN_U32;
    pInternalCore->dataMeasure[0].maxRT = 0;
    pInternalCore->dataMeasure[0].cntCallsRT = 0;
    pInternalCore->dataMeasure[0].accuCallDistance = 0;
    pInternalCore->dataMeasure[0].minCallDistance = RTM_INIT_MIN_U32;
    pInternalCore->dataMeasure[0].maxCallDistance = 0;
}


/** Rtm_Ctrl_TurnOn ********************************************************************************************/
/*!
 * \brief       Turns the runtime measurement on (on multicore called also inside task end hook)
 *
 * \param       uint8_least   Internal core ID of the currently running core
 * \return      void
 *
 * \note        This must be called with disables interrupts
 *
 * It is called from <Rtm_MainFunction> and <Rtm_CrossCoreMainFunction> when a measurement is issued.
 * It will setup the driver.
 */
static FUNC (void, RTM_CODE) Rtm_Ctrl_TurnOn (uint8_least coreId)
{
    uint8_least i;
    /* Pointer to structures */
    Rtm_InternalCore_Type* pInternalCore = &Rtm_Internal.coresValue[coreId];

    /* For each breakpoint unit */
    for (i = 0; i < RTM_CTRL_CONCURRENT_MEASURE; i++)
    {
        /* Systemload measure? */
        if (Rtm_Internal.inputValue[i].idMeasured_u32 == (uint32)&Rtm_MonSystemLoadPer64k_au16)
        {
            pInternalCore->dataMeasure[i].accuRT = Rtm_GetIdleTime(coreId);
        }
#if (RTM_CROSSCORECOM == STD_ON)
        /* Copy global input ID to core local to enable the SW measure */
        pInternalCore->idMeasured_u32[i] = Rtm_Internal.inputValue[i].idMeasured_u32;
#endif
    }

    /* Setup breakpoint units */
    Rtm_Driver_Setup (coreId);

    /* Store start timestamp of sample */
    pInternalCore->timeSampleBegin = Rtm_GetStopwatch ();
}

/** Rtm_Ctrl_Trigger *******************************************************************************************/
/*!
 * \brief       Function for a sample trigger (on multicore called also inside task end hook)
 *
 * \param       uint8_least   Core ID of the currently running core
 * \return      void
 *
 * \note        This must be called with disables interrupts
 *
 * This function does copy the acquired runtime values as fast as possible to the output buffer and resets the internal
 * values to start a new sample. New configuration variables are already set.
 */
static FUNC (void, RTM_CODE) Rtm_Ctrl_Trigger (uint8_least coreId)
{
    uint32 i_u32;

    /* Pointer to structures */
    Rtm_OutputCore_Type* pOutputCore = &Rtm_Output.coresValue[coreId];
    Rtm_InternalCore_Type* pInputCore = &Rtm_Internal.coresValue[coreId];

    /* Calculate sample duration */
    uint32 t_u32 = Rtm_GetStopwatch ();
    pOutputCore->tiSampleDuration_u32 = t_u32 - pInputCore->timeSampleBegin;
    /* Store actual time for sample-duration measurement in next cycle */
    pInputCore->timeSampleBegin = t_u32;

    /* For each conc. measure copy the internal values to out */
    for (i_u32 = 0; i_u32 < RTM_CTRL_CONCURRENT_MEASURE; i_u32++)
    {
        Rtm_OutputValues_Type* pOutput = &pOutputCore->results_ast[i_u32];
        Rtm_InternalValues_Type* pInput = &pInputCore->dataMeasure[i_u32];

        /* Systemload measure for processed cycle? */
        if (Rtm_Internal.inputValue[i_u32].idMeasuredItemLastSample ==
            (uint32)&Rtm_MonSystemLoadPer64k_au16)
        {
            pOutput->averageRT = Rtm_GetIdleTime(coreId) - pInput->accuRT;
            pOutput->callCount = 1;
        }
        else
        {
            /* Copy raw content */
            pOutput->averageRT = pInput->accuRT;
            pOutput->callCount  = pInput->cntCallsRT;
        }
        /* Copy raw content */
        pOutput->cntReentCalls = pInput->cntReentCalls;
        /* Detect a currently active measured element and signal this */
        if (pInput->callBegin != 0)
        {
            pOutput->cntReentCalls |= RTM_MSB_U32;
        }
        pOutput->minRT = pInput->minRT;
        pOutput->maxRT = pInput->maxRT;
        pOutput->averageCallDistance = pInput->accuCallDistance;
        pOutput->minCallDistance = pInput->minCallDistance;
        pOutput->maxCallDistance = pInput->maxCallDistance;

        /* Systemload measure for next cycle? */
        if (Rtm_Internal.inputValue[i_u32].idMeasured_u32 ==
             (uint32)&Rtm_MonSystemLoadPer64k_au16)
        {
            pInput->accuRT = Rtm_GetIdleTime (coreId);
        }
        else
        {
            /* Reset internal values */
            pInput->accuRT = 0;
        }
        /* Reset internal values */
        pInput->minRT = RTM_INIT_MIN_U32;
        pInput->maxRT = 0;
        pInput->accuCallDistance = 0;
        pInput->minCallDistance = RTM_INIT_MIN_U32;
        pInput->maxCallDistance = 0;
        pInput->cntCallsRT = 0;
        pInput->cntReentCalls = 0;
        /* Reset runtime timestamp to detect sample generation while a measured element is active */
        pInput->callBegin = 0;

#if (RTM_CROSSCORECOM == STD_ON)
        /* Copy global input ID to core local to enable the SW measure */
        pInputCore->idMeasured_u32[i_u32] = Rtm_Internal.inputValue[i_u32].idMeasured_u32;
#endif
    }
    /* Setup breakpoint units for next sample */
    Rtm_Driver_Setup (coreId);
}

/** Rtm_Ctrl_TurnOff *******************************************************************************************/
/*!
 * \brief       Halts the current measurement (on multicore called also inside task end hook)
 *
 * \param       uint8_least   Internal core ID of the currently running core
 * \return      void
 *
 * It is called from <Rtm_MainFunction> and <Rtm_CrossCoreMainFunction> to halt the current
 * measurement.
 */
static FUNC (void, RTM_CODE) Rtm_Ctrl_TurnOff (uint8_least coreId)
{
    uint8_least i;
    /* Set id of measured element to not called function */
    for (i = 0; i < RTM_CTRL_CONCURRENT_MEASURE; i++)
    {
        Rtm_Internal.inputValue[i].idMeasured_u32 = NOT_CALLED;
    }
    /* Turn brkp off for each breakpoint unit */
    Rtm_Driver_Disable (coreId);
}

/** Rtm_Ctrl_Configure *****************************************************************************************/
/*!
 * \brief       Configures the runtime measurement
 *
 * \param       void
 * \return      void

 * It is called from <Rtm_MainFunction> when a measurement is issued. It prepares a new configuration for all
 * cores. (preparation will be taken from trigger function)
 */
static FUNC (void, RTM_CODE) Rtm_Ctrl_Configure (void)
{
    uint8_least i_qu8;
    /* Local input structure pointer */
    volatile Rtm_Input_Type* pCtrlInput;
    /* Get input */
    pCtrlInput = SchM_CData_Rtm_Rtm_Input_st();

    /* For each conc. measure */
    for (i_qu8 = 0; i_qu8 < RTM_CTRL_CONCURRENT_MEASURE; i_qu8++)
    {
        /* Pointer to structure, cast to get rid of volatile to speed up code */
        Rtm_InputValues_Type* inp_pst = (Rtm_InputValues_Type*)&pCtrlInput->configs_ast[i_qu8];
        Rtm_InternalInputValues_Type* pInternalCore = &Rtm_Internal.inputValue[i_qu8];

        /* Input id of task is 0..OS_NUM_TASKS-1  if bit 15 is not set
         * Input id of  ISR is 0..OS_NUM_ISRS-1   if bit 15 is set
         * Disable if greater */
        if (inp_pst->idTask_u16 < RTM_NUM_TASKS)
        {
            /* Set address of structure (internal task id) */
            /* MISRA RULE 11.3 VIOLATION: Cast from pointer type to integral type is necessary in this case */
            pInternalCore->idTask =
                (uint32) Rtm_ConvertTaskIdx2ID (inp_pst->idTask_u16);
        }
        else if (((inp_pst->idTask_u16 & RTM_ISR_MODE) != 0) &&
                 ((inp_pst->idTask_u16 & (~RTM_ISR_MODE)) < RTM_NUM_ISRS))
        {
            /* Set address of structure (internal ISR id) */
            /* MISRA RULE 11.3 VIOLATION: Cast from pointer type to integral type is necessary in this case */
            pInternalCore->idTask =
                (uint32) Rtm_ConvertIsrIdx2ID (inp_pst->idTask_u16 & (~RTM_ISR_MODE));
        }
        else
        {
            /* No dependency measure, disable (ISR and task id cannot be zero because they are pointers) */
            pInternalCore->idTask = 0;
        }
        /* Create backup of configuration for idle measure */
        pInternalCore->idMeasuredItemLastSample = pInternalCore->idMeasured_u32;
        /* Copy id */
        pInternalCore->idMeasured_u32 = inp_pst->idMeasured_u32;
    }
}

/** Rtm_Ctrl_GenSample *****************************************************************************************/
/*!
 * \brief       Generates a sample of the currently running measurements
 *
 * \param       uint8_least   Internal core ID of the currently running core
 * \return      void
 *
 * It is called from <Rtm_MainFunction> each time after the sample counter reached the configured value and
 * the frontend is ready to receive new data. All other cores have successfully executed the trigger.
 * It processes the acquired internal data during the sample time and writes the output values.
 */
static FUNC (void, RTM_CODE) Rtm_Ctrl_GenSample (uint8_least coreId)
{
    /* Calculate values for all cores here */
    for (coreId = 0; coreId < RTM_NUM_CORES; coreId++)
    {
        /* Pointer to structure */
        Rtm_OutputCore_Type* pOutputCore = &Rtm_Output.coresValue[coreId];
        Rtm_InternalCore_Type* pInputCore = &Rtm_Internal.coresValue[coreId];

        uint32 i_u32;
        /* For each breakpoint unit */
        for (i_u32 = 0; i_u32 < RTM_CTRL_CONCURRENT_MEASURE; i_u32++)
        {
            /* Pointer to structure */
            Rtm_OutputValues_Type* pOutputResult = &pOutputCore->results_ast[i_u32];

            /*----------------------------*/
            /*           Runtime          */
            /*----------------------------*/
            /* Runtime available? */
            if (pOutputResult->callCount != 0)
            {
                /* Calculate average runtime
                   avrg = (accu - calib * calls) / calls
                        = accu / calls - calib                */
                uint32 t_u32 = (pOutputResult->averageRT / pOutputResult->callCount);
                /* Calibrate with check for underflow */
                pOutputResult->averageRT = (t_u32 < pInputCore->timeCalibrate) ? 0 : t_u32 - pInputCore->timeCalibrate;
                /* Consider calib on extreme runtimes with check for underflow*/
                pOutputResult->minRT = (pOutputResult->minRT < pInputCore->timeCalibrate) ? 0 :
                    pOutputResult->minRT - pInputCore->timeCalibrate;
                pOutputResult->maxRT = (pOutputResult->maxRT < pInputCore->timeCalibrate) ? 0 :
                    pOutputResult->maxRT - pInputCore->timeCalibrate;
            }
            else
            {
                /* No call to item, reset output, avrg and max already 0 */
                pOutputResult->minRT = 0;
            }

            /*----------------------------*/
            /*        Call Distance       */
            /*----------------------------*/
            /* Are call distance variables used for response time? */
            if (pOutputResult->cntReentCalls == RTM_MAX_U32)
            {
                /* Build average (calls for sure > 0 because reentCalls was set) */
                pOutputResult->averageCallDistance = pOutputResult->averageCallDistance / pOutputResult->callCount;
                pOutputResult->cntReentCalls = 0;
            }
            else
            {
                /* Was a measured element active during sample trigger? */
                if ((pOutputResult->cntReentCalls & RTM_MSB_U32) != 0)
                {
                    pOutputResult->cntReentCalls &= ~RTM_MSB_U32;
                    pOutputResult->callCount++;
                }
                /* Add reentrants to calls here */
                pOutputResult->callCount += pOutputResult->cntReentCalls;

                /* Enough calls for call distance? */
                if (pOutputResult->callCount > 2)
                {
                    /* Build average (calls for sure > 1 because of logic of start/reent/end measure) */
                    pOutputResult->averageCallDistance = pOutputResult->averageCallDistance / (pOutputResult->callCount - 1);
                }
            }
            if (pOutputResult->minCallDistance == RTM_INIT_MIN_U32)
            {
                /* Too few calls to item, reset output for call distance (avrg,max already 0) */
                pOutputResult->minCallDistance = 0;
            }
        }
    }
}

#define RTM_STOP_SEC_CODE
#include "Rtm_MemMap.h"

#define RTM_START_SEC_CODE_FAST
#include "Rtm_MemMap.h"

/** Rtm_Ctrl_StartMeasure ******************************************************************************************/
/*!
 * \brief       Handler of a detected measure start.
 *
 * \param       Rtm_InternalValues_Type*   Pointer to the structure which holds the current measurement state
 * \return      void
 *
 * This is called when the driver detects a measure begin.
 */
FUNC (void, RTM_CODE_FAST) Rtm_Ctrl_StartMeasure (Rtm_InternalValues_Type *pIntValue)
{
    uint32 t_u32;

    /* Get timestamp for call distance measurement */
    t_u32 = Rtm_GetStopwatch();

    /* Calculate call distance */
    if (pIntValue->cntCallsRT != 0)
    {
        uint32 t2_u32;
        t2_u32 = t_u32 - pIntValue->callBeginStopWatch;
        /* Update accumulated distance, max and min distance. */
        pIntValue->accuCallDistance += t2_u32;
        if (pIntValue->minCallDistance > t2_u32)
        {
            pIntValue->minCallDistance = t2_u32;
        }
        if (pIntValue->maxCallDistance < t2_u32)
        {
            pIntValue->maxCallDistance = t2_u32;
        }
    }

    /* Set start timestamp for call distance measurement */
    pIntValue->callBeginStopWatch = t_u32;

    /* Set start timestamp for net measurement */
    pIntValue->callBegin = Rtm_GetExecutionTime();
}

/** Rtm_Ctrl_StartMeasureReent ******************************************************************************************/
/*!
 * \brief       Begin the measurement of an element while measure already started.
 *
 * \param       Rtm_InternalValues_Type*   Pointer to the structure which holds the current measurement state.
 * \return      void
 *
 * This is called when reentrant measure begin is detected.
 */
FUNC (void, RTM_CODE_FAST) Rtm_Ctrl_StartMeasureReent (Rtm_InternalValues_Type *pIntValue)
{
    uint32 timestamp;
    uint32 callDistance;

    /* Get timestamp for call distance measurement */
    timestamp = Rtm_GetStopwatch();

    /* Calculate call distance */
    callDistance = timestamp - pIntValue->callBeginStopWatch;
    /* Build statistic */
    pIntValue->accuCallDistance += callDistance;
    if (pIntValue->minCallDistance > callDistance)
    {
        pIntValue->minCallDistance = callDistance;
    }
    if (pIntValue->maxCallDistance < callDistance)
    {
        pIntValue->maxCallDistance = callDistance;
    }

    /* Count occurrence */
    pIntValue->cntReentCalls++;

    /* Set start timestamp for call distance measurement */
    pIntValue->callBeginStopWatch = timestamp;
}

/** Rtm_Ctrl_EndMeasure ****************************************************************************************/
/*!
 * \brief       End the measurement of an element
 *
 * \param       Rtm_InternalValues_Type   Pointer to the structure which holds the current measurement state
 * \return      void
 *
 * This is called when a measure end (not a reentrant) is detected. It is called from the driver.
 */
FUNC (void, RTM_CODE_FAST) Rtm_Ctrl_EndMeasure (Rtm_InternalValues_Type *pIntValue)
{
    uint32 runTime;

    /* Calculate net runtime */
    /* Use special version if it is called from debug trap */
    runTime = Rtm_GetExecutionTime() - pIntValue->callBegin;

#ifdef RTM_DEBUG
    /* Check for underflow */
    if (runTime & 0x80000000)
    {
        runTime = 0;
        Rtm_Assert();
    }
#endif
    /* Reset runtime timestamp to detect sample generation while a measured element is executed */
    pIntValue->callBegin = 0;
    /* Build statistic */
    pIntValue->accuRT += runTime;
    if (pIntValue->minRT > runTime)
    {
        pIntValue->minRT = runTime;
    }
    if (pIntValue->maxRT < runTime)
    {
        pIntValue->maxRT = runTime;
    }
    pIntValue->cntCallsRT++;
}


/** Rtm_Ctrl_ConvertMonMsr *************************************************************************************/
/*!
 * \brief       Process the given task measure values to allow task measure without the use of onchip debug features
 *
 * \param       uint8_least   ID of the measurement slot which should be used
 * \param       uint32        Current net runtime
 * \param       uint32        Current response time (zero for ISRs)
 * \return      void
 *
 * This may be called from <Rtm_TaskEnd> when a task ends which is selected for measurement
 * and from <Rtm_IsrEnd> when an isr ends which is selected for measurement.
 */
FUNC (void, RTM_CODE_FAST) Rtm_Ctrl_ConvertMonMsr (uint8_least id, uint32 runTime, uint32 respTime)
{
    /* Core id */
    const uint8_least coreId = (uint8_least) Rtm_GetLogicalCoreID();

    /* Pointer to structures */
    Rtm_InternalCore_Type* pInternalCore = &Rtm_Internal.coresValue[coreId];
    Rtm_InternalValues_Type* pInternalVal = &pInternalCore->dataMeasure[id];

#if (RTM_CROSSCORECOM == STD_ON)
    /* Time between MainFunction and processing of cross core command must be detected */
    /* Global ID equal to core local? */
    if (pInternalCore->idMeasured_u32[id] != Rtm_Internal.inputValue[id].idMeasured_u32)
    {
        /* No, this measure must be ignored because it would corrupt the buffer */
        return;
    }
#endif

    /* Build statistic */
    pInternalVal->accuRT += runTime;
    if (pInternalVal->minRT > runTime)
    {
        pInternalVal->minRT = runTime;
    }
    if (pInternalVal->maxRT < runTime)
    {
        pInternalVal->maxRT = runTime;
    }
    /* Response time */
    pInternalVal->accuCallDistance += respTime;
    if (pInternalVal->minCallDistance > respTime)
    {
        pInternalVal->minCallDistance = respTime;
    }
    if (pInternalVal->maxCallDistance < respTime)
    {
        pInternalVal->maxCallDistance = respTime;
    }
    pInternalVal->cntCallsRT++;
    /* Signal that call distance variables are used for response time */
    pInternalVal->cntReentCalls = RTM_MAX_U32;
}

#define RTM_STOP_SEC_CODE_FAST
#include "Rtm_MemMap.h"


#endif /* #if (RTM_CTRL == STD_ON) */

/*
 ***********************************************************************************************************************
 * End of file
 ***********************************************************************************************************************
*/

